use rand::{rngs::StdRng, SeedableRng};
use rand_distr::{Distribution, LogNormal, Normal};
use crate::sellers::{Sellers, SellerTrait, SellerConverge};
use crate::campaigns::{Campaigns, MAX_CAMPAIGNS};
use crate::simulationrun::CampaignConverges;
use crate::utils::lognormal_dist;

/// Trait for generating floor CPM values
pub trait FloorGeneratorTrait {
    /// Generate a floor CPM value based on base_impression_ value
    /// 
    /// # Arguments
    /// * `base_impression_value` - Base impression value parameter
    /// * `rng` - Random number generator
    /// 
    /// # Returns
    /// Generated floor CPM value
    fn generate_floor(&self, base_impression_value: f64, rng: &mut StdRng) -> f64;
}

/// Floor generator that always returns a fixed value
pub struct FloorGeneratorFixed {
    pub value: f64,
}

impl FloorGeneratorFixed {
    /// Create a new FloorGeneratorFixed with the given value
    pub fn new(value: f64) -> Box<Self> {
        Box::new(Self { value })
    }
}

impl FloorGeneratorTrait for FloorGeneratorFixed {
    fn generate_floor(&self, _base_impression_value: f64, _rng: &mut StdRng) -> f64 {
        self.value
    }
}

/// Floor generator that uses a lognormal distribution centered around base_value
pub struct FloorGeneratorLogNormal {
    relative_to_impression_value: f64,
    stddev: f64,
}

impl FloorGeneratorLogNormal {
    /// Create a new FloorGeneratorLogNormal with the given standard deviation
    /// The distribution will be centered around base_value when generating floors
    pub fn new(relative_to_impression_value: f64, stddev: f64) -> Box<Self> {
        // Validate stddev by creating a distribution (will be recreated in generate_floor with actual base_value)
        Box::new(Self { relative_to_impression_value, stddev })
    }
}

impl FloorGeneratorTrait for FloorGeneratorLogNormal {
    fn generate_floor(&self, base_impression_value: f64, rng: &mut StdRng) -> f64 {
        // We get the base of the floor as scaling of base_impression_value
        // Create a lognormal distribution centered around base_value using the utility function
        let dist = lognormal_dist(base_impression_value * self.relative_to_impression_value, self.stddev);
        Distribution::sample(&dist, rng).max(0.0) // Ensure floor is non-negative
    }
}

/// Represents the winner of an auction
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq)]
pub enum Winner {
    Campaign { 
        campaign_id: usize, 
        virtual_cost: f64,
        buyer_charge: f64,
    },
    OTHER_DEMAND,
    BELOW_FLOOR,
    NO_DEMAND,
}

/// Represents the result of an auction, subsuming the winner with cost information
#[derive(Debug, Clone, PartialEq)]
pub struct AuctionResult {
    pub winner: Winner,
    pub supply_cost: f64,
}

/// Object-safe wrapper for Distribution<f64> that works with StdRng
/// This is needed because Distribution<f64> cannot be made into a trait object
/// due to its generic sample method
pub trait DistributionF64 {
    fn sample(&self, rng: &mut StdRng) -> f64;
}

impl<D: Distribution<f64>> DistributionF64 for D {
    fn sample(&self, rng: &mut StdRng) -> f64 {
        Distribution::sample(self, rng)
    }
}

/// Struct for providing distribution parameters for impression generation
/// Contains pre-initialized distribution boxes
pub struct ImpressionsParam {
    pub base_impression_value_dist: Box<dyn DistributionF64>,
    pub value_to_campaign_multiplier_dist: Box<dyn DistributionF64>,
}

impl ImpressionsParam {
    /// Create a new ImpressionsParam with Distribution<f64> types
    /// The distributions will be boxed internally
    pub fn new<D1, D2>(
        base_impression_value_dist: D1,
        value_to_campaign_multiplier_dist: D2,
    ) -> Self
    where
        D1: Distribution<f64> + 'static,
        D2: Distribution<f64> + 'static,
    {
        Self {
            base_impression_value_dist: Box::new(base_impression_value_dist),
            value_to_campaign_multiplier_dist: Box::new(value_to_campaign_multiplier_dist),
        }
    }
}

/// Represents competition information for an impression
#[derive(Debug, Clone)]
pub struct ImpressionCompetition {
    pub bid_cpm: f64,
    /// Imaginary predicted parameter generated by adding noise to parameters of logistic distribution used to sample for best_other_bid_cpm
    pub win_rate_prediction_sigmoid_offset: f64,
    /// Imaginary predicted parameter generated by adding noise to parameters of logistic distribution used to sample for best_other_bid_cpm
    pub win_rate_prediction_sigmoid_scale: f64,
    pub win_rate_actual_sigmoid_offset: f64,
    pub win_rate_actual_sigmoid_scale: f64,
}

impl ImpressionCompetition {
    // Empty impl - generation moved to CompetitionGeneratorParametrizedLogNormal
}

/// Trait for generating impression competition information
pub trait CompetitionGeneratorTrait {
    /// Generate competition information for an impression
    /// 
    /// # Arguments
    /// * `rng` - Random number generator
    /// 
    /// # Returns
    /// `Some(ImpressionCompetition)` if competition should be generated, `None` otherwise
    fn generate_competition(&self, rng: &mut StdRng) -> Option<ImpressionCompetition>;
}

/// Competition generator that always returns None (no competition)
pub struct CompetitionGeneratorNone;

impl CompetitionGeneratorNone {
    /// Create a new CompetitionGeneratorNone generator
    pub fn new() -> Box<Self> {
        Box::new(Self)
    }
}

impl CompetitionGeneratorTrait for CompetitionGeneratorNone {
    fn generate_competition(&self, _rng: &mut StdRng) -> Option<ImpressionCompetition> {
        None
    }
}

/// Generator for impression competition information using parametrized lognormal distributions
/// 
/// Holds distributions used to generatively build competition that resembles real world.
pub struct CompetitionGeneratorParametrizedLogNormal {
    /// Distribution for actual sigmoid offset (centered around value_base, stddev=5.0)
    actual_offset_dist: LogNormal<f64>,
    /// Distribution for actual sigmoid scale (mean=2.0, stddev=1.0)
    actual_scale_dist: LogNormal<f64>,
    /// Distribution for multiplicative gaussian noise (mean=1.0, stddev=1.0)
    noise_mult_dist: Normal<f64>,
    /// Distribution for additive gaussian noise (mean=1.0, stddev=1.0)
    noise_add_dist: Normal<f64>,
}

impl CompetitionGeneratorParametrizedLogNormal {
    /// Create a new generator with distributions initialized
    /// 
    /// # Arguments
    /// * `value_base` - Base value parameter used to center the actual sigmoid offset
    pub fn new(value_base: f64) -> Box<Self> {
        Box::new(Self {
            // With current parameters, we end up with 0.3% of impressions at zero bid
            actual_offset_dist: crate::utils::lognormal_dist(value_base, 3.0),
            actual_scale_dist: crate::utils::lognormal_dist(2.0, 1.0),
            noise_mult_dist: Normal::new(1.0, 1.0).unwrap(),
            noise_add_dist: Normal::new(1.0, 1.0).unwrap(),
        })
    }
}

impl CompetitionGeneratorTrait for CompetitionGeneratorParametrizedLogNormal {
    /// Generate competition information for an impression.
    /// 
    /// This function generatively builds competition that resembles real world, based on
    /// various distributions.
    /// 
    /// # Arguments
    /// * `rng` - Random number generator
    /// 
    /// # Returns
    /// A new `ImpressionCompetition` instance with generated parameters
    fn generate_competition(&self, rng: &mut StdRng) -> Option<ImpressionCompetition> {
        // Generate win_rate_actual_sigmoid_offset based on lognormal distribution
        // centered around value_base, with some stddev.
        // TODO: Maybe lognormal is not the right distribution and we might want something
        // that is more uniform.
        let win_rate_actual_sigmoid_offset = Distribution::sample(&self.actual_offset_dist, rng);
        
        // Generate win_rate_actual_sigmoid_scale by sampling from lognormal with mean 2 and stddev 1
        let win_rate_actual_sigmoid_scale = Distribution::sample(&self.actual_scale_dist, rng);
        
        // Sample competing bid by sampling from logistic distribution using actual parameters
        let mut bid_cpm = crate::utils::sample_logistic_bid(
            win_rate_actual_sigmoid_offset,
            win_rate_actual_sigmoid_scale,
            rng,
        );
        
        // Clip the competing bid (bid_cpm) to be above zero
        bid_cpm = bid_cpm.max(0.0);
        
        // Add multiplicative gaussian noise to get win_rate_prediction_sigmoid_offset
        let noise_mult = Distribution::sample(&self.noise_mult_dist, rng);
        let win_rate_prediction_sigmoid_offset = win_rate_actual_sigmoid_offset * noise_mult;
        
        // Add additive gaussian noise to get win_rate_prediction_sigmoid_scale
        let noise_add = Distribution::sample(&self.noise_add_dist, rng);
        let win_rate_prediction_sigmoid_scale = win_rate_actual_sigmoid_scale + noise_add;
        
        Some(ImpressionCompetition {
            bid_cpm,
            win_rate_prediction_sigmoid_offset,
            win_rate_prediction_sigmoid_scale,
            win_rate_actual_sigmoid_offset,
            win_rate_actual_sigmoid_scale,
        })
    }
}

/// Represents an impression on offer
#[derive(Debug, Clone)]
pub struct Impression {
    pub seller_id: usize,
    pub competition: Option<ImpressionCompetition>,
    pub floor_cpm: f64,
    pub value_to_campaign_id: [f64; MAX_CAMPAIGNS],
}

impl Impression {

    /// Run an auction for this impression with the given campaigns, campaign converges, seller, and seller convergence parameters
    /// Returns the auction result
    pub fn run_auction(&self, campaigns: &Campaigns, campaign_converges: &CampaignConverges, seller: &dyn SellerTrait, seller_converge: &dyn SellerConverge) -> AuctionResult {
        // Get bids from all campaigns
        let mut winning_bid_cpm = 0.0;
        let mut winning_campaign_id: Option<usize> = None;

        // Get seller_boost_factor from seller convergence parameter
        let seller_converge_boost = seller_converge.as_any().downcast_ref::<crate::sellers::SellerConvergeBoost>().unwrap();
        let seller_boost_factor = seller_converge_boost.boost_factor;

        for campaign in &campaigns.campaigns {
            let campaign_id = campaign.campaign_id();
            let campaign_converge = &campaign_converges.campaign_converges[campaign_id];
            // Use the trait method for get_bid
            let bid = campaign.get_bid(self, campaign_converge.as_ref(), seller_boost_factor);
            if bid > winning_bid_cpm {
                winning_bid_cpm = bid;
                winning_campaign_id = Some(campaign_id);
            }
        }

        // Determine the result based on winning bid
        // Check all failure conditions first, then create winner in one place
        let (winner, supply_cost) = 'result: {
            // No campaigns participated
            let campaign_id = match winning_campaign_id {
                Some(id) => id,
                None => break 'result (Winner::NO_DEMAND, seller.get_supply_cost_cpm(0.0) / 1000.0),
            };
            
            // Winning bid is below floor - no winner
            if winning_bid_cpm < self.floor_cpm {
                break 'result (Winner::BELOW_FLOOR, seller.get_supply_cost_cpm(0.0) / 1000.0);
            }
            
            // Check competition if it exists
            if let Some(competition) = &self.competition {
                // Winning bid is below best other bid - other demand wins
                if winning_bid_cpm < competition.bid_cpm {
                    break 'result (Winner::OTHER_DEMAND, seller.get_supply_cost_cpm(0.0) / 1000.0);
                }
            }
            
            // Valid winner - bid passes all checks (floor and competition if present)
            // Set cost values - virtual_cost and buyer_charge are always the winning bid
            let supply_cost = seller.get_supply_cost_cpm(winning_bid_cpm) / 1000.0;
            let virtual_cost = winning_bid_cpm / 1000.0;
            let buyer_charge = winning_bid_cpm / 1000.0;
            
            // Convert from CPM to actual cost by dividing by 1000
            (Winner::Campaign {
                campaign_id,
                virtual_cost,
                buyer_charge,
            }, supply_cost)
        };

        AuctionResult {
            winner,
            supply_cost,
        }
    }
}

/// Container for impressions with methods to create impressions
pub struct Impressions {
    pub impressions: Vec<Impression>,
}

impl Impressions {
    /// Create a new Impressions container and populate it from sellers
    pub fn new(sellers: &Sellers, params: &ImpressionsParam) -> Self {
        // Use deterministic seed for reproducible results
        let mut rng = StdRng::seed_from_u64(999);

        let mut impressions = Vec::new();

        for seller in &sellers.sellers {
            for _ in 0..seller.num_impressions() {
                // First calculate base impression value (needed for floor generation)
                let base_impression_value = params.base_impression_value_dist.sample(&mut rng);
                
                let (competition, floor_cpm) = seller.generate_impression(
                    base_impression_value,
                    &mut rng,
                );
                //println!("Base impression value: {:.4}", base_impression_value);
                // Then generate values for each campaign by multiplying base value with campaign-specific multiplier
                let mut value_to_campaign_id = [0.0; MAX_CAMPAIGNS];
                for i in 0..MAX_CAMPAIGNS {
                    let multiplier = params.value_to_campaign_multiplier_dist.sample(&mut rng);
                //    println!("Campaign {} multiplier: {:.4}", i, multiplier);
                    value_to_campaign_id[i] = base_impression_value * multiplier;
                }

                impressions.push(Impression {
                    seller_id: seller.seller_id(),
                    competition,
                    floor_cpm,
                    value_to_campaign_id,
                });
            }
        }

        Self { impressions }
    }
}


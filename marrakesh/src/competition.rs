use rand::rngs::StdRng;
use rand_distr::Distribution;
use crate::utils::lognormal_dist;

// Generating realistic competition parameters is a complex problem.
// Using simple sampling of logistic parameters leads to a lot of impressions high value of win probability at near-zero bid, which is not realistic
// Therefore we use a rejection sampling to avoid that

/// Represents competition information for an impression
#[derive(Debug, Clone)]
pub struct ImpressionCompetition {
    pub bid_cpm: f64,
    /// Imaginary predicted parameter generated by adding noise to parameters of logistic distribution used to sample for best_other_bid_cpm
    pub win_rate_prediction_sigmoid_offset: f64,
    /// Imaginary predicted parameter generated by adding noise to parameters of logistic distribution used to sample for best_other_bid_cpm
    pub win_rate_prediction_sigmoid_scale: f64,
    pub win_rate_actual_sigmoid_offset: f64,
    pub win_rate_actual_sigmoid_scale: f64,
}

/// Trait for generating impression competition information
pub trait CompetitionGeneratorTrait {
    /// Generate competition information for an impression
    /// 
    /// # Arguments
    /// * `base_impression_value` - The base value of the impression
    /// * `rng` - Random number generator
    /// 
    /// # Returns
    /// `Some(ImpressionCompetition)` if competition should be generated, `None` otherwise
    fn generate_competition(&self, base_impression_value: f64, rng: &mut StdRng) -> Option<ImpressionCompetition>;
}

/// Competition generator that always returns None (no competition)
pub struct CompetitionGeneratorNone;

impl CompetitionGeneratorNone {
    /// Create a new CompetitionGeneratorNone generator
    pub fn new() -> Box<Self> {
        Box::new(Self)
    }
}

impl CompetitionGeneratorTrait for CompetitionGeneratorNone {
    fn generate_competition(&self, _base_impression_value: f64, _rng: &mut StdRng) -> Option<ImpressionCompetition> {
        None
    }
}

/// Generator for impression competition information using parametrized lognormal distributions
/// 
/// Holds distributions used to generatively build competition that resembles real world.
pub struct CompetitionGeneratorParametrizedLogNormal {
    /// Distribution for actual sigmoid offset (centered around value_base, stddev=5.0)
    actual_offset_dist: rand_distr::LogNormal<f64>,
    /// Distribution for actual sigmoid scale (mean=2.0, stddev=1.0)
    actual_scale_dist: rand_distr::LogNormal<f64>,
    /// Distribution for offset lognormal noise (mean=1.0, stddev=0.5)
    noise_offset_dist: rand_distr::LogNormal<f64>,
    /// Distribution for scale lognormal noise (mean=1.0, stddev=0.5)
    noise_scale_dist: rand_distr::LogNormal<f64>,
}

impl CompetitionGeneratorParametrizedLogNormal {
    /// Create a new generator with distributions initialized
    /// 
    /// # Arguments
    /// * `value_base` - Base value parameter used to center the actual sigmoid offset
    pub fn new(value_base: f64) -> Box<Self> {
        Box::new(Self {
            // With current parameters, we end up with 0.3% of impressions at zero bid
            actual_offset_dist: lognormal_dist(value_base, 3.0),
            actual_scale_dist: lognormal_dist(1.5, 1.0),
            noise_offset_dist: lognormal_dist(1.0, 0.3),
            noise_scale_dist: lognormal_dist(1.0, 0.3),
        })
    }
}

impl CompetitionGeneratorTrait for CompetitionGeneratorParametrizedLogNormal {
    /// Generate competition information for an impression.
    /// 
    /// This function generatively builds competition that resembles real world, based on
    /// various distributions.
    /// 
    /// # Arguments
    /// * `base_impression_value` - The base value of the impression
    /// * `rng` - Random number generator
    /// 
    /// # Returns
    /// A new `ImpressionCompetition` instance with generated parameters
    fn generate_competition(&self, base_impression_value: f64, rng: &mut StdRng) -> Option<ImpressionCompetition> {
        // Rejection sampling for win_rate_actual_sigmoid_offset and win_rate_actual_sigmoid_scale
        // Reject if sigmoid.get_probability(0.0) > 0.01
        let (win_rate_actual_sigmoid_offset, win_rate_actual_sigmoid_scale) = loop {
            // Generate win_rate_actual_sigmoid_offset based on lognormal distribution
            // centered around value_base, with some stddev.
            //let offset = Distribution::sample(&self.actual_offset_dist, rng);
            let offset = base_impression_value;
            let scale = Distribution::sample(&self.actual_scale_dist, rng).min(4.0);
            
            // Create a temporary sigmoid to evaluate the rejection criterion
            let temp_sigmoid = crate::sigmoid::Sigmoid::new(offset, scale, 1.0);
            let prob_at_zero = temp_sigmoid.get_probability(0.0);
            
            // Accept if probability at 0.0 is <= 0.01
            if prob_at_zero <= 0.02 {
                break (offset, scale);
            }
            // Otherwise, reject and resample
        };
        
        // Sample competing bid by sampling from logistic distribution using actual parameters
        let mut bid_cpm = crate::utils::sample_logistic_bid(
            win_rate_actual_sigmoid_offset,
            win_rate_actual_sigmoid_scale,
            rng,
        );
        
        // Clip the competing bid (bid_cpm) to be above zero
        bid_cpm = bid_cpm.max(0.0);
        
        // Add multiplicative lognormal noise to get win_rate_prediction_sigmoid_offset
        //let noise_offset = Distribution::sample(&self.noise_offset_dist, rng);
        let noise_offset = 1.0;
        let win_rate_prediction_sigmoid_offset = win_rate_actual_sigmoid_offset * noise_offset;
        
        // Add multiplicative lognormal noise to get win_rate_prediction_sigmoid_scale
        //let noise_scale = Distribution::sample(&self.noise_scale_dist, rng);
        let noise_scale = 1.0;
        let win_rate_prediction_sigmoid_scale = win_rate_actual_sigmoid_scale * noise_scale;
        
        Some(ImpressionCompetition {
            bid_cpm,
            win_rate_prediction_sigmoid_offset,
            win_rate_prediction_sigmoid_scale,
            win_rate_actual_sigmoid_offset,
            win_rate_actual_sigmoid_scale,
        })
    }
}

